{"ast":null,"code":"var _jsxFileName = \"D:\\\\\\u0424\\u0430\\u0439\\u043B\\u044B\\\\\\u0412\\u044F\\u0442\\u0413\\u0423\\\\2 \\u043A\\u0443\\u0440\\u0441\\\\\\u0421\\u0435\\u043C\\u0435\\u0441\\u0442\\u0440 4\\\\Web\\\\\\u043A\\u0443\\u0440\\u0441\\u0430\\u0447\\\\audio-service\\\\audio-service-client\\\\src\\\\components\\\\AudioContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect, useRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { debounce } from \"lodash\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioContext = /*#__PURE__*/createContext();\nexport const useAudioContext = () => {\n  _s();\n  return useContext(AudioContext);\n};\n_s(useAudioContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AudioProvider = ({\n  children\n}) => {\n  _s2();\n  const [currentTrack, setCurrentTrack] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [volume, setVolume] = useState(1);\n  const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\n  const [currentTime, setCurrentTime] = useState(0);\n  const audioRef = useRef(null);\n  const [currentPlaylistId, setCurrentPlaylistId] = useState(-2);\n  const [playlistId, setPlaylistId] = useState(-1);\n  const [currentPLaylist, setCurrentPlaylis] = useState(null);\n  const [audioFiles, setAudioFiles] = useState([]);\n  const [localAudioFiles, setLocalAudioFiles] = useState([]);\n  const [audioId, setAudioId] = useState(-1);\n  const clearAudioFiles = () => {\n    setAudioFiles([]);\n  };\n  useEffect(() => {\n    console.log(\"useEffect currentPlaylistId:\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId);\n  }, [currentPlaylistId]);\n\n  // useEffect(() => {\n  //   setCurrentPlaylistId(playlistId);\n  // }, [playlistId]);\n\n  const updateAudioFiles = data => {\n    if (currentPlaylistId !== playlistId || !isPlaying) {\n      console.log(\"Обновлен audioFiles\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId);\n      if (!isPlaying) {\n        setAudioFiles(data);\n      }\n      if (!isPlaying || currentPlaylistId !== playlistId) {\n        setCurrentPlaylistId(playlistId);\n        setLocalAudioFiles(data);\n      }\n    }\n    // setLocalAudioFiles(data);\n  };\n  const updatePlaylist = data => {\n    if (currentPlaylistId !== playlistId || !isPlaying) {\n      setLocalAudioFiles(data);\n      if (!isPlaying) {\n        setAudioFiles(data);\n      }\n    }\n  };\n  const togglePlay = () => {\n    setIsPlaying(!isPlaying);\n  };\n  useEffect(() => {\n    if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\n      setCurrentTrack({\n        id: audioFiles[currentTrackIndex].id,\n        audioUrl: audioFiles[currentTrackIndex].audioUrl,\n        trackName: audioFiles[currentTrackIndex].title,\n        author: audioFiles[currentTrackIndex].author,\n        imageUrl: audioFiles[currentTrackIndex].image ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}` : \"\",\n        duration: audioFiles[currentTrackIndex].duration\n      });\n    }\n  }, [currentTrackIndex]);\n  const playNextTrack = async () => {\n    if (currentTrackIndex === audioFiles.length - 1) return;\n    let nextIndex = currentTrackIndex + 1;\n    while (nextIndex < audioFiles.length) {\n      const nextTrack = audioFiles[nextIndex];\n      // if (nextTrack.playlistId === currentPlaylistId) {\n      setCurrentTrackIndex(nextIndex);\n      try {\n        // const response = await fetch(\n        //   `http://localhost:8080/api/audio/${nextTrack.id}`\n        // );\n        // if (!response.ok) {\n        //   throw new Error(`HTTP error! status: ${response.status}`);\n        // }\n        // const blob = await response.blob();\n        // const audioData = URL.createObjectURL(blob);\n\n        setCurrentTrack({\n          id: nextTrack.id,\n          // audioUrl: audioData,\n          audioUrl: nextTrack.audioData,\n          trackName: nextTrack.title,\n          author: nextTrack.author,\n          imageUrl: nextTrack.image ? `data:image/jpeg;base64,${nextTrack.image.data}` : \"\",\n          duration: nextTrack.duration\n        });\n        setIsPlaying(true);\n        return;\n      } catch (error) {\n        console.error(\"Error fetching audio:\", error);\n      }\n      // }\n      nextIndex++;\n    }\n  };\n  const playPreviousTrack = async () => {\n    if (currentTrackIndex === 0) return;\n    console.log(\"Предыдущий трек:\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId + \"\\n\\nтекущий трек = \" + audioFiles[currentTrackIndex].title + \"\\nпредыдущий трек = \" + audioFiles[currentTrackIndex - 1].title);\n    let previousIndex = currentTrackIndex - 1;\n    while (previousIndex >= 0) {\n      const previousTrack = audioFiles[previousIndex];\n      // if (previousTrack.playlistId === currentPlaylistId) {\n      // setCurrentPlaylistId(playlistId);\n\n      setCurrentTrackIndex(previousIndex);\n      try {\n        // const response = await fetch(\n        //   `http://localhost:8080/api/audio/${previousTrack.id}`\n        // );\n        // if (!response.ok) {\n        //   throw new Error(`HTTP error! status: ${response.status}`);\n        // }\n        // const blob = await response.blob();\n        // const audioData = URL.createObjectURL(blob);\n\n        setCurrentTrack({\n          id: previousTrack.id,\n          // audioUrl: audioData,\n          audioUrl: previousTrack.audioData,\n          trackName: previousTrack.title,\n          author: previousTrack.author,\n          imageUrl: previousTrack.image ? `data:image/jpeg;base64,${previousTrack.image.data}` : \"\",\n          duration: previousTrack.duration\n        });\n        setIsPlaying(true);\n        return;\n      } catch (error) {\n        console.error(\"Error fetching audio:\", error);\n      }\n\n      // }\n      previousIndex--;\n    }\n  };\n\n  // const playPreviousTrack = async () => {\n  //   if (currentTrackIndex === 0) return;\n\n  //   console.log(\n  //     \"Предыдущий трек:\\n\\ncurrentPlaylistId = \" +\n  //       currentPlaylistId +\n  //       \"\\nplaylistId = \" +\n  //       playlistId\n  //   );\n\n  //   let previousIndex = currentTrackIndex - 1;\n  //   while (previousIndex >= 0) {\n  //     const previousTrack = audioFiles[previousIndex];\n  //     // if (previousTrack.playlistId === currentPlaylistId) {\n  //       setCurrentTrackIndex(previousIndex);\n  //       try {\n  //         const response = await fetch(\n  //           `http://localhost:8080/api/audio/${previousTrack.id}`\n  //         );\n  //         if (!response.ok) {\n  //           throw new Error(`HTTP error! status: ${response.status}`);\n  //         }\n  //         const blob = await response.blob();\n  //         const audioData = URL.createObjectURL(blob);\n\n  //         setCurrentTrack({\n  //           id: previousTrack.id,\n  //           audioUrl: audioData,\n  //           trackName: previousTrack.title,\n  //           author: previousTrack.author,\n  //           imageUrl: previousTrack.image\n  //             ? `data:image/jpeg;base64,${previousTrack.image.data}`\n  //             : \"\",\n  //           duration: previousTrack.duration,\n  //         });\n  //         setIsPlaying(true);\n  //         return;\n  //       } catch (error) {\n  //         console.error(\"Error fetching audio:\", error);\n  //       }\n  //     // }\n  //     previousIndex--;\n  //   }\n  // };\n\n  // Задержка перед следующим вызовом\n  const debouncedPlayNextTrack = debounce(() => {\n    if (currentTrackIndex !== -1) {\n      playNextTrack();\n    }\n  }, 500);\n  const debouncedPlayPreviousTrack = debounce(() => {\n    if (currentTrackIndex !== -1) {\n      playPreviousTrack();\n    }\n  }, 500);\n  useEffect(() => {\n    if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\n      const fetchAudioAndPlay = async () => {\n        try {\n          const response = await fetch(`http://localhost:8080/api/audio/${audioFiles[currentTrackIndex].id}`);\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          const blob = await response.blob();\n          const audioData = URL.createObjectURL(new Blob([blob]));\n\n          // setCurrentPlaylistId(playlistId);\n\n          setCurrentTrack({\n            id: audioFiles[currentTrackIndex].id,\n            audioUrl: audioData,\n            trackName: audioFiles[currentTrackIndex].title,\n            author: audioFiles[currentTrackIndex].author,\n            imageUrl: audioFiles[currentTrackIndex].image ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}` : \"\",\n            duration: audioFiles[currentTrackIndex].duration\n          });\n          setIsPlaying(true);\n        } catch (error) {\n          console.error(\"Error fetching audio:\", error);\n        }\n      };\n      fetchAudioAndPlay();\n      audioRef.current.volume = volume;\n    }\n  }, [currentTrackIndex]);\n  return /*#__PURE__*/_jsxDEV(AudioContext.Provider, {\n    value: {\n      currentTrack,\n      setCurrentTrack,\n      isPlaying,\n      setIsPlaying,\n      togglePlay,\n      volume,\n      setVolume,\n      audioFiles,\n      updateAudioFiles,\n      currentTrackIndex,\n      setCurrentTrackIndex,\n      audioRef,\n      debouncedPlayNextTrack,\n      debouncedPlayPreviousTrack,\n      currentTime,\n      setCurrentTime,\n      clearAudioFiles,\n      currentPlaylistId,\n      setCurrentPlaylistId,\n      playlistId,\n      setPlaylistId,\n      localAudioFiles,\n      setLocalAudioFiles,\n      updatePlaylist,\n      audioId,\n      setAudioId,\n      currentPLaylist,\n      setCurrentPlaylis\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 280,\n    columnNumber: 5\n  }, this);\n};\n_s2(AudioProvider, \"SiYOs2TLsfweU8kF740EixiJbyo=\");\n_c = AudioProvider;\nAudioProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\nvar _c;\n$RefreshReg$(_c, \"AudioProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useRef","PropTypes","debounce","jsxDEV","_jsxDEV","AudioContext","useAudioContext","_s","AudioProvider","children","_s2","currentTrack","setCurrentTrack","isPlaying","setIsPlaying","volume","setVolume","currentTrackIndex","setCurrentTrackIndex","currentTime","setCurrentTime","audioRef","currentPlaylistId","setCurrentPlaylistId","playlistId","setPlaylistId","currentPLaylist","setCurrentPlaylis","audioFiles","setAudioFiles","localAudioFiles","setLocalAudioFiles","audioId","setAudioId","clearAudioFiles","console","log","updateAudioFiles","data","updatePlaylist","togglePlay","id","audioUrl","trackName","title","author","imageUrl","image","duration","playNextTrack","length","nextIndex","nextTrack","audioData","error","playPreviousTrack","previousIndex","previousTrack","debouncedPlayNextTrack","debouncedPlayPreviousTrack","fetchAudioAndPlay","response","fetch","ok","Error","status","blob","URL","createObjectURL","Blob","current","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","propTypes","node","isRequired","$RefreshReg$"],"sources":["D:/Файлы/ВятГУ/2 курс/Семестр 4/Web/курсач/audio-service/audio-service-client/src/components/AudioContext.jsx"],"sourcesContent":["import React, {\r\n  createContext,\r\n  useState,\r\n  useContext,\r\n  useEffect,\r\n  useRef,\r\n} from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { debounce } from \"lodash\";\r\n\r\nconst AudioContext = createContext();\r\n\r\nexport const useAudioContext = () => useContext(AudioContext);\r\n\r\nexport const AudioProvider = ({ children }) => {\r\n  const [currentTrack, setCurrentTrack] = useState(null);\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [volume, setVolume] = useState(1);\r\n\r\n  const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const audioRef = useRef(null);\r\n\r\n  const [currentPlaylistId, setCurrentPlaylistId] = useState(-2);\r\n  const [playlistId, setPlaylistId] = useState(-1);\r\n\r\n  const [currentPLaylist, setCurrentPlaylis] = useState(null);\r\n\r\n  const [audioFiles, setAudioFiles] = useState([]);\r\n  const [localAudioFiles, setLocalAudioFiles] = useState([]);\r\n\r\n  const [audioId, setAudioId] = useState(-1);\r\n\r\n  const clearAudioFiles = () => {\r\n    setAudioFiles([]);\r\n  };\r\n\r\n  useEffect(() => {\r\n    console.log(\r\n      \"useEffect currentPlaylistId:\\n\\ncurrentPlaylistId = \" +\r\n        currentPlaylistId +\r\n        \"\\nplaylistId = \" +\r\n        playlistId\r\n    );\r\n  }, [currentPlaylistId]);\r\n\r\n  // useEffect(() => {\r\n  //   setCurrentPlaylistId(playlistId);\r\n  // }, [playlistId]);\r\n\r\n  const updateAudioFiles = (data) => {\r\n    if (currentPlaylistId !== playlistId || !isPlaying) {\r\n      console.log(\"Обновлен audioFiles\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId);\r\n      if (!isPlaying) {\r\n        setAudioFiles(data);\r\n      }\r\n      if (!isPlaying || currentPlaylistId !== playlistId) {\r\n        setCurrentPlaylistId(playlistId);\r\n        setLocalAudioFiles(data);\r\n      }\r\n    }\r\n    // setLocalAudioFiles(data);\r\n  };\r\n\r\n  const updatePlaylist = (data) => {\r\n    if (currentPlaylistId !== playlistId || !isPlaying) {\r\n      setLocalAudioFiles(data);\r\n      if (!isPlaying) {\r\n        setAudioFiles(data);\r\n      }\r\n    }\r\n  };\r\n\r\n  const togglePlay = () => {\r\n    setIsPlaying(!isPlaying);\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\r\n      setCurrentTrack({\r\n        id: audioFiles[currentTrackIndex].id,\r\n        audioUrl: audioFiles[currentTrackIndex].audioUrl,\r\n        trackName: audioFiles[currentTrackIndex].title,\r\n        author: audioFiles[currentTrackIndex].author,\r\n        imageUrl: audioFiles[currentTrackIndex].image\r\n          ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\r\n          : \"\", \r\n        duration: audioFiles[currentTrackIndex].duration,\r\n      });\r\n    }\r\n  }, [currentTrackIndex]);\r\n\r\n  const playNextTrack = async () => {\r\n    if (currentTrackIndex === audioFiles.length - 1) return;\r\n\r\n    let nextIndex = currentTrackIndex + 1;\r\n    while (nextIndex < audioFiles.length) {\r\n      const nextTrack = audioFiles[nextIndex];\r\n      // if (nextTrack.playlistId === currentPlaylistId) {\r\n      setCurrentTrackIndex(nextIndex);\r\n      try {\r\n        // const response = await fetch(\r\n        //   `http://localhost:8080/api/audio/${nextTrack.id}`\r\n        // );\r\n        // if (!response.ok) {\r\n        //   throw new Error(`HTTP error! status: ${response.status}`);\r\n        // }\r\n        // const blob = await response.blob();\r\n        // const audioData = URL.createObjectURL(blob);\r\n\r\n        setCurrentTrack({\r\n          id: nextTrack.id,\r\n          // audioUrl: audioData,\r\n          audioUrl: nextTrack.audioData,\r\n          trackName: nextTrack.title,\r\n          author: nextTrack.author,\r\n          imageUrl: nextTrack.image\r\n            ? `data:image/jpeg;base64,${nextTrack.image.data}`\r\n            : \"\",\r\n          duration: nextTrack.duration,\r\n        });\r\n        setIsPlaying(true);\r\n        return;\r\n      } catch (error) {\r\n        console.error(\"Error fetching audio:\", error);\r\n      }\r\n      // }\r\n      nextIndex++;\r\n    }\r\n  };\r\n\r\n  const playPreviousTrack = async () => {\r\n    if (currentTrackIndex === 0) return;\r\n\r\n    console.log(\r\n      \"Предыдущий трек:\\n\\ncurrentPlaylistId = \" +\r\n        currentPlaylistId +\r\n        \"\\nplaylistId = \" +\r\n        playlistId +\r\n        \"\\n\\nтекущий трек = \" +\r\n        audioFiles[currentTrackIndex].title +\r\n        \"\\nпредыдущий трек = \" +\r\n        audioFiles[currentTrackIndex - 1].title\r\n    );\r\n\r\n    let previousIndex = currentTrackIndex - 1;\r\n    while (previousIndex >= 0) {\r\n      const previousTrack = audioFiles[previousIndex];\r\n      // if (previousTrack.playlistId === currentPlaylistId) {\r\n      // setCurrentPlaylistId(playlistId);\r\n\r\n      setCurrentTrackIndex(previousIndex);\r\n      try {\r\n        // const response = await fetch(\r\n        //   `http://localhost:8080/api/audio/${previousTrack.id}`\r\n        // );\r\n        // if (!response.ok) {\r\n        //   throw new Error(`HTTP error! status: ${response.status}`);\r\n        // }\r\n        // const blob = await response.blob();\r\n        // const audioData = URL.createObjectURL(blob);\r\n\r\n        setCurrentTrack({\r\n          id: previousTrack.id,\r\n          // audioUrl: audioData,\r\n          audioUrl: previousTrack.audioData,\r\n          trackName: previousTrack.title,\r\n          author: previousTrack.author,\r\n          imageUrl: previousTrack.image\r\n            ? `data:image/jpeg;base64,${previousTrack.image.data}`\r\n            : \"\",\r\n          duration: previousTrack.duration,\r\n        });\r\n        setIsPlaying(true);\r\n        return;\r\n      } catch (error) {\r\n        console.error(\"Error fetching audio:\", error);\r\n      }\r\n\r\n      // }\r\n      previousIndex--;\r\n    }\r\n  };\r\n\r\n  // const playPreviousTrack = async () => {\r\n  //   if (currentTrackIndex === 0) return;\r\n\r\n  //   console.log(\r\n  //     \"Предыдущий трек:\\n\\ncurrentPlaylistId = \" +\r\n  //       currentPlaylistId +\r\n  //       \"\\nplaylistId = \" +\r\n  //       playlistId\r\n  //   );\r\n\r\n  //   let previousIndex = currentTrackIndex - 1;\r\n  //   while (previousIndex >= 0) {\r\n  //     const previousTrack = audioFiles[previousIndex];\r\n  //     // if (previousTrack.playlistId === currentPlaylistId) {\r\n  //       setCurrentTrackIndex(previousIndex);\r\n  //       try {\r\n  //         const response = await fetch(\r\n  //           `http://localhost:8080/api/audio/${previousTrack.id}`\r\n  //         );\r\n  //         if (!response.ok) {\r\n  //           throw new Error(`HTTP error! status: ${response.status}`);\r\n  //         }\r\n  //         const blob = await response.blob();\r\n  //         const audioData = URL.createObjectURL(blob);\r\n\r\n  //         setCurrentTrack({\r\n  //           id: previousTrack.id,\r\n  //           audioUrl: audioData,\r\n  //           trackName: previousTrack.title,\r\n  //           author: previousTrack.author,\r\n  //           imageUrl: previousTrack.image\r\n  //             ? `data:image/jpeg;base64,${previousTrack.image.data}`\r\n  //             : \"\",\r\n  //           duration: previousTrack.duration,\r\n  //         });\r\n  //         setIsPlaying(true);\r\n  //         return;\r\n  //       } catch (error) {\r\n  //         console.error(\"Error fetching audio:\", error);\r\n  //       }\r\n  //     // }\r\n  //     previousIndex--;\r\n  //   }\r\n  // };\r\n\r\n  // Задержка перед следующим вызовом\r\n  const debouncedPlayNextTrack = debounce(() => {\r\n    if (currentTrackIndex !== -1) {\r\n      playNextTrack();\r\n    }\r\n  }, 500);\r\n\r\n  const debouncedPlayPreviousTrack = debounce(() => {\r\n    if (currentTrackIndex !== -1) {\r\n      playPreviousTrack();\r\n    }\r\n  }, 500);\r\n\r\n  useEffect(() => {\r\n    if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\r\n      const fetchAudioAndPlay = async () => {\r\n        try {\r\n          const response = await fetch(\r\n            `http://localhost:8080/api/audio/${audioFiles[currentTrackIndex].id}`\r\n          );\r\n          if (!response.ok) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n          }\r\n          const blob = await response.blob();\r\n          const audioData = URL.createObjectURL(new Blob([blob]));\r\n\r\n          // setCurrentPlaylistId(playlistId);\r\n\r\n          setCurrentTrack({\r\n            id: audioFiles[currentTrackIndex].id,\r\n            audioUrl: audioData,\r\n            trackName: audioFiles[currentTrackIndex].title,\r\n            author: audioFiles[currentTrackIndex].author,\r\n            imageUrl: audioFiles[currentTrackIndex].image\r\n              ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\r\n              : \"\",\r\n            duration: audioFiles[currentTrackIndex].duration,\r\n          });\r\n          setIsPlaying(true);\r\n        } catch (error) {\r\n          console.error(\"Error fetching audio:\", error);\r\n        }\r\n      };\r\n\r\n      fetchAudioAndPlay();\r\n      audioRef.current.volume = volume;\r\n    }\r\n  }, [currentTrackIndex]);\r\n\r\n  return (\r\n    <AudioContext.Provider\r\n      value={{\r\n        currentTrack,\r\n        setCurrentTrack,\r\n        isPlaying,\r\n        setIsPlaying,\r\n        togglePlay,\r\n        volume,\r\n        setVolume,\r\n        audioFiles,\r\n        updateAudioFiles,\r\n        currentTrackIndex,\r\n        setCurrentTrackIndex,\r\n        audioRef,\r\n        debouncedPlayNextTrack,\r\n        debouncedPlayPreviousTrack,\r\n        currentTime,\r\n        setCurrentTime,\r\n        clearAudioFiles,\r\n        currentPlaylistId,\r\n        setCurrentPlaylistId,\r\n        playlistId,\r\n        setPlaylistId,\r\n        localAudioFiles,\r\n        setLocalAudioFiles,\r\n        updatePlaylist,\r\n        audioId,\r\n        setAudioId,\r\n        currentPLaylist,\r\n        setCurrentPlaylis,\r\n      }}\r\n    >\r\n      {children}\r\n    </AudioContext.Provider>\r\n  );\r\n};\r\n\r\nAudioProvider.propTypes = {\r\n  children: PropTypes.node.isRequired,\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}