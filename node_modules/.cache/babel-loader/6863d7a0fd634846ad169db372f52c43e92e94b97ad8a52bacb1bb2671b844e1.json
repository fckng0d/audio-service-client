{"ast":null,"code":"var _jsxFileName = \"D:\\\\\\u0424\\u0430\\u0439\\u043B\\u044B\\\\\\u0412\\u044F\\u0442\\u0413\\u0423\\\\2 \\u043A\\u0443\\u0440\\u0441\\\\\\u0421\\u0435\\u043C\\u0435\\u0441\\u0442\\u0440 4\\\\Web\\\\\\u043A\\u0443\\u0440\\u0441\\u0430\\u0447\\\\audio-service\\\\audio-service-client\\\\src\\\\components\\\\AudioContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// import React, {\n//   createContext,\n//   useState,\n//   useContext,\n//   useEffect,\n//   useRef,\n// } from \"react\";\n// import PropTypes from \"prop-types\";\n// import { debounce } from \"lodash\";\n\n// const AudioContext = createContext();\n\n// export const useAudioContext = () => useContext(AudioContext);\n\n// export const AudioProvider = ({ children }) => {\n//   const [currentTrack, setCurrentTrack] = useState(null);\n//   const [isPlaying, setIsPlaying] = useState(false);\n//   const [volume, setVolume] = useState(1);\n\n//   const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\n//   const [currentTime, setCurrentTime] = useState(0);\n//   const audioRef = useRef(null);\n\n//   const [currentPlaylistId, setCurrentPlaylistId] = useState(-2);\n//   const [playlistId, setPlaylistId] = useState(-1);\n\n//   const [currentPLaylist, setCurrentPlaylis] = useState(null);\n\n//   const [audioFiles, setAudioFiles] = useState([]);\n//   const [localAudioFiles, setLocalAudioFiles] = useState([]);\n\n//   const [audioId, setAudioId] = useState(-1);\n\n//   const clearAudioFiles = () => {\n//     setAudioFiles([]);\n//   };\n\n//   useEffect(() => {\n//     console.log(\n//       \"useEffect currentPlaylistId:\\n\\ncurrentPlaylistId = \" +\n//         currentPlaylistId +\n//         \"\\nplaylistId = \" +\n//         playlistId\n//     );\n//   }, [currentPlaylistId]);\n\n//   // useEffect(() => {\n//   //   setCurrentPlaylistId(playlistId);\n//   // }, [playlistId]);\n\n//   const updateAudioFiles = (data) => {\n//     setLocalAudioFiles(data);\n//     if (currentPlaylistId === playlistId && !isPlaying) {\n//       console.log(\"Обновлен audioFiles\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId);\n//       // setCurrentPlaylistId(playlistId);\n//       setAudioFiles(data);\n//       // if (!isPlaying || currentPlaylistId !== playlistId) {\n//       //   setLocalAudioFiles(data);\n//       // }\n//     }\n//     // setLocalAudioFiles(data);\n//   };\n\n//   const updatePlaylist = (data) => {\n//     if (currentPlaylistId !== playlistId || !isPlaying) {\n//       setLocalAudioFiles(data);\n//       if (!isPlaying) {\n//         setAudioFiles(data);\n//       }\n//     }\n//   };\n\n//   const togglePlay = () => {\n//     setIsPlaying(!isPlaying);\n//   };\n\n//   // useEffect(() => {\n//   //   if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\n//   //     setCurrentTrack({\n//   //       id: audioFiles[currentTrackIndex].id,\n//   //       audioUrl: audioFiles[currentTrackIndex].audioUrl,\n//   //       trackName: audioFiles[currentTrackIndex].title,\n//   //       author: audioFiles[currentTrackIndex].author,\n//   //       imageUrl: audioFiles[currentTrackIndex].image\n//   //         ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\n//   //         : \"\",\n//   //       duration: audioFiles[currentTrackIndex].duration,\n//   //     });\n//   //   }\n//   // }, [currentTrackIndex]);\n\n//   const playNextTrack = async () => {\n//     if (currentTrackIndex === audioFiles.length - 1) return;\n\n//     let nextIndex = currentTrackIndex + 1;\n//     while (nextIndex < audioFiles.length) {\n//       const nextTrack = audioFiles[nextIndex];\n//       // if (nextTrack.playlistId === currentPlaylistId) {\n//       setCurrentTrackIndex(nextIndex);\n//       try {\n//         const response = await fetch(\n//           `http://localhost:8080/api/audio/${nextTrack.id}`\n//         );\n//         if (!response.ok) {\n//           throw new Error(`HTTP error! status: ${response.status}`);\n//         }\n//         const blob = await response.blob();\n//         const audioData = URL.createObjectURL(blob);\n\n//         setCurrentTrack({\n//           id: nextTrack.id,\n//           audioUrl: audioData,\n//           // audioUrl: nextTrack.audioData,\n//           trackName: nextTrack.title,\n//           author: nextTrack.author,\n//           imageUrl: nextTrack.image\n//             ? `data:image/jpeg;base64,${nextTrack.image.data}`\n//             : \"\",\n//           duration: nextTrack.duration,\n//         });\n//         setIsPlaying(true);\n//         return;\n//       } catch (error) {\n//         console.error(\"Error fetching audio:\", error);\n//       }\n//       // }\n//       nextIndex++;\n//     }\n//   };\n\n//   const playPreviousTrack = async () => {\n//     if (currentTrackIndex === 0) return;\n\n//     console.log(\n//       \"Предыдущий трек:\\n\\ncurrentPlaylistId = \" +\n//         currentPlaylistId +\n//         \"\\nplaylistId = \" +\n//         playlistId +\n//         \"\\n\\nтекущий трек = \" +\n//         audioFiles[currentTrackIndex].title +\n//         \"\\nпредыдущий трек = \" +\n//         audioFiles[currentTrackIndex - 1].title\n//     );\n\n//     let previousIndex = currentTrackIndex - 1;\n//     while (previousIndex >= 0) {\n//       const previousTrack = audioFiles[previousIndex];\n//       // if (previousTrack.playlistId === currentPlaylistId) {\n//       // setCurrentPlaylistId(playlistId);\n\n//       setCurrentTrackIndex(previousIndex);\n//       try {\n//         const response = await fetch(\n//           `http://localhost:8080/api/audio/${previousTrack.id}`\n//         );\n//         if (!response.ok) {\n//           throw new Error(`HTTP error! status: ${response.status}`);\n//         }\n//         const blob = await response.blob();\n//         const audioData = URL.createObjectURL(blob);\n\n//         setCurrentTrack({\n//           id: previousTrack.id,\n//           audioUrl: audioData,\n//           // audioUrl: previousTrack.audioData,\n//           trackName: previousTrack.title,\n//           author: previousTrack.author,\n//           imageUrl: previousTrack.image\n//             ? `data:image/jpeg;base64,${previousTrack.image.data}`\n//             : \"\",\n//           duration: previousTrack.duration,\n//         });\n//         setIsPlaying(true);\n//         return;\n//       } catch (error) {\n//         console.error(\"Error fetching audio:\", error);\n//       }\n\n//       // }\n//       previousIndex--;\n//     }\n//   };\n\n//   // const playPreviousTrack = async () => {\n//   //   if (currentTrackIndex === 0) return;\n\n//   //   console.log(\n//   //     \"Предыдущий трек:\\n\\ncurrentPlaylistId = \" +\n//   //       currentPlaylistId +\n//   //       \"\\nplaylistId = \" +\n//   //       playlistId\n//   //   );\n\n//   //   let previousIndex = currentTrackIndex - 1;\n//   //   while (previousIndex >= 0) {\n//   //     const previousTrack = audioFiles[previousIndex];\n//   //     // if (previousTrack.playlistId === currentPlaylistId) {\n//   //       setCurrentTrackIndex(previousIndex);\n//   //       try {\n//   //         const response = await fetch(\n//   //           `http://localhost:8080/api/audio/${previousTrack.id}`\n//   //         );\n//   //         if (!response.ok) {\n//   //           throw new Error(`HTTP error! status: ${response.status}`);\n//   //         }\n//   //         const blob = await response.blob();\n//   //         const audioData = URL.createObjectURL(blob);\n\n//   //         setCurrentTrack({\n//   //           id: previousTrack.id,\n//   //           audioUrl: audioData,\n//   //           trackName: previousTrack.title,\n//   //           author: previousTrack.author,\n//   //           imageUrl: previousTrack.image\n//   //             ? `data:image/jpeg;base64,${previousTrack.image.data}`\n//   //             : \"\",\n//   //           duration: previousTrack.duration,\n//   //         });\n//   //         setIsPlaying(true);\n//   //         return;\n//   //       } catch (error) {\n//   //         console.error(\"Error fetching audio:\", error);\n//   //       }\n//   //     // }\n//   //     previousIndex--;\n//   //   }\n//   // };\n\n//   // Задержка перед следующим вызовом\n//   const debouncedPlayNextTrack = debounce(() => {\n//     if (currentTrackIndex !== -1) {\n//       playNextTrack();\n//     }\n//   }, 500);\n\n//   const debouncedPlayPreviousTrack = debounce(() => {\n//     if (currentTrackIndex !== -1) {\n//       playPreviousTrack();\n//     }\n//   }, 500);\n\n//   useEffect(() => {\n//     if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\n//       // console.log(\"useEffect GET audio:\\n\\n\" + \"audioFiles: \" + audioFiles[currentTrackIndex].title);\n//       const fetchAudioAndPlay = async () => {\n//         try {\n//           const response = await fetch(\n//             `http://localhost:8080/api/audio/${audioFiles[currentTrackIndex].id}`\n//           );\n//           if (!response.ok) {\n//             throw new Error(`HTTP error! status: ${response.status}`);\n//           }\n//           const blob = await response.blob();\n//           const audioData = URL.createObjectURL(new Blob([blob]));\n\n//           if (playlistId !== currentPlaylistId) {\n\n//             setCurrentPlaylistId(playlistId);\n//             console.log(\"setCurrentPlaylistId: = \" + currentPlaylistId);\n//           }\n\n//           setCurrentTrack({\n//             id: audioFiles[currentTrackIndex].id,\n//             audioUrl: audioData,\n//             trackName: audioFiles[currentTrackIndex].title,\n//             author: audioFiles[currentTrackIndex].author,\n//             imageUrl: audioFiles[currentTrackIndex].image\n//               ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\n//               : \"\",\n//             duration: audioFiles[currentTrackIndex].duration,\n//           });\n//           setIsPlaying(true);\n//         } catch (error) {\n//           console.error(\"Error fetching audio:\", error);\n//         }\n//       };\n\n//       fetchAudioAndPlay();\n//       audioRef.current.volume = volume;\n//     }\n//   }, [currentTrackIndex]);\n\n//   return (\n//     <AudioContext.Provider\n//       value={{\n//         currentTrack,\n//         setCurrentTrack,\n//         isPlaying,\n//         setIsPlaying,\n//         togglePlay,\n//         volume,\n//         setVolume,\n//         audioFiles,\n//         updateAudioFiles,\n//         currentTrackIndex,\n//         setCurrentTrackIndex,\n//         audioRef,\n//         debouncedPlayNextTrack,\n//         debouncedPlayPreviousTrack,\n//         currentTime,\n//         setCurrentTime,\n//         clearAudioFiles,\n//         currentPlaylistId,\n//         setCurrentPlaylistId,\n//         playlistId,\n//         setPlaylistId,\n//         localAudioFiles,\n//         setLocalAudioFiles,\n//         updatePlaylist,\n//         audioId,\n//         setAudioId,\n//         currentPLaylist,\n//         setCurrentPlaylis,\n//       }}\n//     >\n//       {children}\n//     </AudioContext.Provider>\n//   );\n// };\n\n// AudioProvider.propTypes = {\n//   children: PropTypes.node.isRequired,\n// };\n\nimport React, { createContext, useState, useContext, useEffect, useRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { debounce } from \"lodash\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioContext = /*#__PURE__*/createContext();\nexport const useAudioContext = () => {\n  _s();\n  return useContext(AudioContext);\n};\n_s(useAudioContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AudioProvider = ({\n  children\n}) => {\n  _s2();\n  const [currentTrack, setCurrentTrack] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [volume, setVolume] = useState(1);\n  const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\n  const [currentTime, setCurrentTime] = useState(0);\n  const audioRef = useRef(null);\n  const [currentPlaylistId, setCurrentPlaylistId] = useState(-2);\n  const [playlistId, setPlaylistId] = useState(-1);\n  const [currentPLaylist, setCurrentPlaylis] = useState(null);\n  const initialPlaylistData = {\n    id: null,\n    name: '',\n    author: '',\n    countOfAudio: 0,\n    duration: 0.0,\n    image: null,\n    audioFiles: []\n  };\n  const [playlistData, setPlaylistData] = useState(initialPlaylistData);\n  const [localAudioFiles, setLocalAudioFiles] = useState([]);\n  const [audioId, setAudioId] = useState(-1);\n  const clearLocalAudioFiles = () => {\n    setLocalAudioFiles([]);\n  };\n  useEffect(() => {\n    console.log(\"useEffect currentPlaylistId:\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId);\n  }, [currentPlaylistId]);\n  const updatePlaylist = playlistData => {\n    if (currentPlaylistId === playlistId || !isPlaying) {\n      console.log(\"Обновлен playlistData\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId);\n      setPlaylistData(playlistData);\n      console.log(playlistData);\n    }\n  };\n  const togglePlay = () => {\n    setIsPlaying(!isPlaying);\n  };\n  useEffect(() => {\n    if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\n      if (currentTrackIndex !== -1 && currentPlaylistId === playlistId && playlistData && playlistData.audioFiles && playlistData.audioFiles[currentTrackIndex]) {\n        const track = playlistData.audioFiles.find(file => file.id === currentTrackIndex);\n        setCurrentTrack({\n          id: track.id,\n          audioUrl: track.audioData,\n          trackName: track.title,\n          author: track.author,\n          imageUrl: track.image ? `data:image/jpeg;base64,${track.image.data}` : \"\",\n          duration: playlistData.audioFiles[currentTrackIndex].duration\n        });\n      }\n    }\n  }, [currentTrackIndex]);\n  const playNextTrack = async () => {\n    console.log(\"playlistData: \" + playlistData);\n    if (!playlistData || !playlistData.audioFiles || currentTrackIndex === -1) return;\n    console.log(\"NextTrack:\\n\\ncurrentTrackIndex = \" + currentTrackIndex + \"\\nразмер плейлиста\" + playlistData.audioFiles.length - 1);\n\n    // if (currentTrackIndex === playlistData.audioFiles.length - 1) return;\n\n    let nextIndex = currentTrackIndex + 1;\n    // if (nextIndex < playlistData.audioFiles.length) {\n    const nextTrack = playlistData.audioFiles.find(file => file.id === nextIndex);\n    setCurrentTrackIndex(nextIndex);\n    try {\n      setCurrentTrack({\n        id: nextTrack.id,\n        audioUrl: nextTrack.audioData,\n        trackName: nextTrack.title,\n        author: nextTrack.author,\n        imageUrl: nextTrack.image ? `data:image/jpeg;base64,${nextTrack.image.data}` : \"\",\n        duration: nextTrack.duration\n      });\n      setIsPlaying(true);\n    } catch (error) {\n      console.error(\"Error fetching audio:\", error);\n    }\n    // }\n  };\n  const playPreviousTrack = async () => {\n    if (currentTrackIndex === 0) return;\n    console.log(\"Предыдущий трек:\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId + \"\\n\\nтекущий трек = \" + audioFiles[currentTrackIndex].title + \"\\nпредыдущий трек = \" + audioFiles[currentTrackIndex - 1].title);\n    let previousIndex = currentTrackIndex - 1;\n    while (previousIndex >= 0) {\n      const previousTrack = playlistData.audioFiles[previousIndex];\n      // if (previousTrack.playlistId === currentPlaylistId) {\n      // setCurrentPlaylistId(playlistId);\n\n      setCurrentTrackIndex(previousIndex);\n      try {\n        // const response = await fetch(\n        //   `http://localhost:8080/api/audio/${previousTrack.id}`\n        // );\n        // if (!response.ok) {\n        //   throw new Error(`HTTP error! status: ${response.status}`);\n        // }\n        // const blob = await response.blob();\n        // const audioData = URL.createObjectURL(blob);\n\n        setCurrentTrack({\n          id: previousTrack.id,\n          // audioUrl: audioData,\n          audioUrl: previousTrack.audioData,\n          trackName: previousTrack.title,\n          author: previousTrack.author,\n          imageUrl: previousTrack.image ? `data:image/jpeg;base64,${previousTrack.image.data}` : \"\",\n          duration: previousTrack.duration\n        });\n        setIsPlaying(true);\n        return;\n      } catch (error) {\n        console.error(\"Error fetching audio:\", error);\n      }\n\n      // }\n      previousIndex--;\n    }\n  };\n\n  // Задержка перед следующим вызовом\n  const debouncedPlayNextTrack = () => {\n    console.log(\"currentTrackIndex = \" + currentTrackIndex);\n    if (currentTrackIndex !== -1) {\n      playNextTrack();\n    }\n  };\n\n  // const debouncedPlayNextTrack = debounce(() => {\n  //   console.log(ЖcurrentTrackIndex);\n  //   if (currentTrackIndex !== -1) {\n  //     playNextTrack();\n  //   }\n  // }, 500);\n\n  const debouncedPlayPreviousTrack = () => {\n    console.log(\"currentTrackIndex = \" + currentTrackIndex);\n    if (currentTrackIndex !== -1) {\n      playPreviousTrack();\n    }\n  };\n  useEffect(() => {\n    if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\n      const fetchAudioAndPlay = async () => {\n        try {\n          if (currentTrackIndex !== -1 && currentPlaylistId === playlistId && playlistData && playlistData.audioFiles && playlistData.audioFiles[currentTrackIndex]) {\n            const response = await fetch(`http://localhost:8080/api/audio/${playlistData.audioFiles[currentTrackIndex].id}`);\n            if (!response.ok) {\n              throw new Error(`HTTP error! status: ${response.status}`);\n            }\n            const blob = await response.blob();\n            const audioData = URL.createObjectURL(new Blob([blob]));\n            setCurrentPlaylistId(playlistId);\n            console.log(\"playlistData:\", playlistData, \"currentTrackIndex:\", currentTrackIndex, \"playlistData.audioFiles:\", playlistData.audioFiles, \"playlistData.audioFiles[currentTrackIndex]:\", playlistData.audioFiles[currentTrackIndex]);\n            setCurrentTrack({\n              id: playlistData.audioFiles[currentTrackIndex].id,\n              audioUrl: audioData,\n              trackName: playlistData.audioFiles[currentTrackIndex].title,\n              author: playlistData.audioFiles[currentTrackIndex].author,\n              imageUrl: playlistData.audioFiles[currentTrackIndex].image ? `data:image/jpeg;base64,${playlistData.audioFiles[currentTrackIndex].image.data}` : \"\",\n              duration: playlistData.audioFiles[currentTrackIndex].duration\n            });\n          }\n          setIsPlaying(true);\n        } catch (error) {\n          console.error(\"Error fetching audio:\", error);\n        }\n      };\n      fetchAudioAndPlay();\n      audioRef.current.volume = volume;\n    }\n  }, [currentTrackIndex]);\n  return /*#__PURE__*/_jsxDEV(AudioContext.Provider, {\n    value: {\n      currentTrack,\n      setCurrentTrack,\n      isPlaying,\n      setIsPlaying,\n      togglePlay,\n      volume,\n      setVolume,\n      currentTrackIndex,\n      setCurrentTrackIndex,\n      audioRef,\n      debouncedPlayNextTrack,\n      debouncedPlayPreviousTrack,\n      currentTime,\n      setCurrentTime,\n      // clearAudioFiles,\n      currentPlaylistId,\n      setCurrentPlaylistId,\n      playlistId,\n      setPlaylistId,\n      localAudioFiles,\n      setLocalAudioFiles,\n      updatePlaylist,\n      audioId,\n      setAudioId,\n      currentPLaylist,\n      setCurrentPlaylis,\n      clearLocalAudioFiles\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 586,\n    columnNumber: 5\n  }, this);\n};\n_s2(AudioProvider, \"i4AwVBqggXMLZ5GNv4vDDV+PjQY=\");\n_c = AudioProvider;\nAudioProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\nvar _c;\n$RefreshReg$(_c, \"AudioProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useRef","PropTypes","debounce","jsxDEV","_jsxDEV","AudioContext","useAudioContext","_s","AudioProvider","children","_s2","currentTrack","setCurrentTrack","isPlaying","setIsPlaying","volume","setVolume","currentTrackIndex","setCurrentTrackIndex","currentTime","setCurrentTime","audioRef","currentPlaylistId","setCurrentPlaylistId","playlistId","setPlaylistId","currentPLaylist","setCurrentPlaylis","initialPlaylistData","id","name","author","countOfAudio","duration","image","audioFiles","playlistData","setPlaylistData","localAudioFiles","setLocalAudioFiles","audioId","setAudioId","clearLocalAudioFiles","console","log","updatePlaylist","togglePlay","track","find","file","audioUrl","audioData","trackName","title","imageUrl","data","playNextTrack","length","nextIndex","nextTrack","error","playPreviousTrack","previousIndex","previousTrack","debouncedPlayNextTrack","debouncedPlayPreviousTrack","fetchAudioAndPlay","response","fetch","ok","Error","status","blob","URL","createObjectURL","Blob","current","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","propTypes","node","isRequired","$RefreshReg$"],"sources":["D:/Файлы/ВятГУ/2 курс/Семестр 4/Web/курсач/audio-service/audio-service-client/src/components/AudioContext.jsx"],"sourcesContent":["// import React, {\r\n//   createContext,\r\n//   useState,\r\n//   useContext,\r\n//   useEffect,\r\n//   useRef,\r\n// } from \"react\";\r\n// import PropTypes from \"prop-types\";\r\n// import { debounce } from \"lodash\";\r\n\r\n// const AudioContext = createContext();\r\n\r\n// export const useAudioContext = () => useContext(AudioContext);\r\n\r\n// export const AudioProvider = ({ children }) => {\r\n//   const [currentTrack, setCurrentTrack] = useState(null);\r\n//   const [isPlaying, setIsPlaying] = useState(false);\r\n//   const [volume, setVolume] = useState(1);\r\n\r\n//   const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\r\n//   const [currentTime, setCurrentTime] = useState(0);\r\n//   const audioRef = useRef(null);\r\n\r\n//   const [currentPlaylistId, setCurrentPlaylistId] = useState(-2);\r\n//   const [playlistId, setPlaylistId] = useState(-1);\r\n\r\n//   const [currentPLaylist, setCurrentPlaylis] = useState(null);\r\n\r\n//   const [audioFiles, setAudioFiles] = useState([]);\r\n//   const [localAudioFiles, setLocalAudioFiles] = useState([]);\r\n\r\n//   const [audioId, setAudioId] = useState(-1);\r\n\r\n//   const clearAudioFiles = () => {\r\n//     setAudioFiles([]);\r\n//   };\r\n\r\n//   useEffect(() => {\r\n//     console.log(\r\n//       \"useEffect currentPlaylistId:\\n\\ncurrentPlaylistId = \" +\r\n//         currentPlaylistId +\r\n//         \"\\nplaylistId = \" +\r\n//         playlistId\r\n//     );\r\n//   }, [currentPlaylistId]);\r\n\r\n//   // useEffect(() => {\r\n//   //   setCurrentPlaylistId(playlistId);\r\n//   // }, [playlistId]);\r\n\r\n//   const updateAudioFiles = (data) => {\r\n//     setLocalAudioFiles(data);\r\n//     if (currentPlaylistId === playlistId && !isPlaying) {\r\n//       console.log(\"Обновлен audioFiles\\n\\ncurrentPlaylistId = \" + currentPlaylistId + \"\\nplaylistId = \" + playlistId);\r\n//       // setCurrentPlaylistId(playlistId);\r\n//       setAudioFiles(data);\r\n//       // if (!isPlaying || currentPlaylistId !== playlistId) {\r\n//       //   setLocalAudioFiles(data);\r\n//       // }\r\n//     }\r\n//     // setLocalAudioFiles(data);\r\n//   };\r\n\r\n//   const updatePlaylist = (data) => {\r\n//     if (currentPlaylistId !== playlistId || !isPlaying) {\r\n//       setLocalAudioFiles(data);\r\n//       if (!isPlaying) {\r\n//         setAudioFiles(data);\r\n//       }\r\n//     }\r\n//   };\r\n\r\n//   const togglePlay = () => {\r\n//     setIsPlaying(!isPlaying);\r\n//   };\r\n\r\n//   // useEffect(() => {\r\n//   //   if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\r\n//   //     setCurrentTrack({\r\n//   //       id: audioFiles[currentTrackIndex].id,\r\n//   //       audioUrl: audioFiles[currentTrackIndex].audioUrl,\r\n//   //       trackName: audioFiles[currentTrackIndex].title,\r\n//   //       author: audioFiles[currentTrackIndex].author,\r\n//   //       imageUrl: audioFiles[currentTrackIndex].image\r\n//   //         ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\r\n//   //         : \"\",\r\n//   //       duration: audioFiles[currentTrackIndex].duration,\r\n//   //     });\r\n//   //   }\r\n//   // }, [currentTrackIndex]);\r\n\r\n//   const playNextTrack = async () => {\r\n//     if (currentTrackIndex === audioFiles.length - 1) return;\r\n\r\n//     let nextIndex = currentTrackIndex + 1;\r\n//     while (nextIndex < audioFiles.length) {\r\n//       const nextTrack = audioFiles[nextIndex];\r\n//       // if (nextTrack.playlistId === currentPlaylistId) {\r\n//       setCurrentTrackIndex(nextIndex);\r\n//       try {\r\n//         const response = await fetch(\r\n//           `http://localhost:8080/api/audio/${nextTrack.id}`\r\n//         );\r\n//         if (!response.ok) {\r\n//           throw new Error(`HTTP error! status: ${response.status}`);\r\n//         }\r\n//         const blob = await response.blob();\r\n//         const audioData = URL.createObjectURL(blob);\r\n\r\n//         setCurrentTrack({\r\n//           id: nextTrack.id,\r\n//           audioUrl: audioData,\r\n//           // audioUrl: nextTrack.audioData,\r\n//           trackName: nextTrack.title,\r\n//           author: nextTrack.author,\r\n//           imageUrl: nextTrack.image\r\n//             ? `data:image/jpeg;base64,${nextTrack.image.data}`\r\n//             : \"\",\r\n//           duration: nextTrack.duration,\r\n//         });\r\n//         setIsPlaying(true);\r\n//         return;\r\n//       } catch (error) {\r\n//         console.error(\"Error fetching audio:\", error);\r\n//       }\r\n//       // }\r\n//       nextIndex++;\r\n//     }\r\n//   };\r\n\r\n//   const playPreviousTrack = async () => {\r\n//     if (currentTrackIndex === 0) return;\r\n\r\n//     console.log(\r\n//       \"Предыдущий трек:\\n\\ncurrentPlaylistId = \" +\r\n//         currentPlaylistId +\r\n//         \"\\nplaylistId = \" +\r\n//         playlistId +\r\n//         \"\\n\\nтекущий трек = \" +\r\n//         audioFiles[currentTrackIndex].title +\r\n//         \"\\nпредыдущий трек = \" +\r\n//         audioFiles[currentTrackIndex - 1].title\r\n//     );\r\n\r\n//     let previousIndex = currentTrackIndex - 1;\r\n//     while (previousIndex >= 0) {\r\n//       const previousTrack = audioFiles[previousIndex];\r\n//       // if (previousTrack.playlistId === currentPlaylistId) {\r\n//       // setCurrentPlaylistId(playlistId);\r\n\r\n//       setCurrentTrackIndex(previousIndex);\r\n//       try {\r\n//         const response = await fetch(\r\n//           `http://localhost:8080/api/audio/${previousTrack.id}`\r\n//         );\r\n//         if (!response.ok) {\r\n//           throw new Error(`HTTP error! status: ${response.status}`);\r\n//         }\r\n//         const blob = await response.blob();\r\n//         const audioData = URL.createObjectURL(blob);\r\n\r\n//         setCurrentTrack({\r\n//           id: previousTrack.id,\r\n//           audioUrl: audioData,\r\n//           // audioUrl: previousTrack.audioData,\r\n//           trackName: previousTrack.title,\r\n//           author: previousTrack.author,\r\n//           imageUrl: previousTrack.image\r\n//             ? `data:image/jpeg;base64,${previousTrack.image.data}`\r\n//             : \"\",\r\n//           duration: previousTrack.duration,\r\n//         });\r\n//         setIsPlaying(true);\r\n//         return;\r\n//       } catch (error) {\r\n//         console.error(\"Error fetching audio:\", error);\r\n//       }\r\n\r\n//       // }\r\n//       previousIndex--;\r\n//     }\r\n//   };\r\n\r\n//   // const playPreviousTrack = async () => {\r\n//   //   if (currentTrackIndex === 0) return;\r\n\r\n//   //   console.log(\r\n//   //     \"Предыдущий трек:\\n\\ncurrentPlaylistId = \" +\r\n//   //       currentPlaylistId +\r\n//   //       \"\\nplaylistId = \" +\r\n//   //       playlistId\r\n//   //   );\r\n\r\n//   //   let previousIndex = currentTrackIndex - 1;\r\n//   //   while (previousIndex >= 0) {\r\n//   //     const previousTrack = audioFiles[previousIndex];\r\n//   //     // if (previousTrack.playlistId === currentPlaylistId) {\r\n//   //       setCurrentTrackIndex(previousIndex);\r\n//   //       try {\r\n//   //         const response = await fetch(\r\n//   //           `http://localhost:8080/api/audio/${previousTrack.id}`\r\n//   //         );\r\n//   //         if (!response.ok) {\r\n//   //           throw new Error(`HTTP error! status: ${response.status}`);\r\n//   //         }\r\n//   //         const blob = await response.blob();\r\n//   //         const audioData = URL.createObjectURL(blob);\r\n\r\n//   //         setCurrentTrack({\r\n//   //           id: previousTrack.id,\r\n//   //           audioUrl: audioData,\r\n//   //           trackName: previousTrack.title,\r\n//   //           author: previousTrack.author,\r\n//   //           imageUrl: previousTrack.image\r\n//   //             ? `data:image/jpeg;base64,${previousTrack.image.data}`\r\n//   //             : \"\",\r\n//   //           duration: previousTrack.duration,\r\n//   //         });\r\n//   //         setIsPlaying(true);\r\n//   //         return;\r\n//   //       } catch (error) {\r\n//   //         console.error(\"Error fetching audio:\", error);\r\n//   //       }\r\n//   //     // }\r\n//   //     previousIndex--;\r\n//   //   }\r\n//   // };\r\n\r\n//   // Задержка перед следующим вызовом\r\n//   const debouncedPlayNextTrack = debounce(() => {\r\n//     if (currentTrackIndex !== -1) {\r\n//       playNextTrack();\r\n//     }\r\n//   }, 500);\r\n\r\n//   const debouncedPlayPreviousTrack = debounce(() => {\r\n//     if (currentTrackIndex !== -1) {\r\n//       playPreviousTrack();\r\n//     }\r\n//   }, 500);\r\n\r\n//   useEffect(() => {\r\n//     if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\r\n//       // console.log(\"useEffect GET audio:\\n\\n\" + \"audioFiles: \" + audioFiles[currentTrackIndex].title);\r\n//       const fetchAudioAndPlay = async () => {\r\n//         try {\r\n//           const response = await fetch(\r\n//             `http://localhost:8080/api/audio/${audioFiles[currentTrackIndex].id}`\r\n//           );\r\n//           if (!response.ok) {\r\n//             throw new Error(`HTTP error! status: ${response.status}`);\r\n//           }\r\n//           const blob = await response.blob();\r\n//           const audioData = URL.createObjectURL(new Blob([blob]));\r\n\r\n//           if (playlistId !== currentPlaylistId) {\r\n\r\n//             setCurrentPlaylistId(playlistId);\r\n//             console.log(\"setCurrentPlaylistId: = \" + currentPlaylistId);\r\n//           }\r\n\r\n//           setCurrentTrack({\r\n//             id: audioFiles[currentTrackIndex].id,\r\n//             audioUrl: audioData,\r\n//             trackName: audioFiles[currentTrackIndex].title,\r\n//             author: audioFiles[currentTrackIndex].author,\r\n//             imageUrl: audioFiles[currentTrackIndex].image\r\n//               ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\r\n//               : \"\",\r\n//             duration: audioFiles[currentTrackIndex].duration,\r\n//           });\r\n//           setIsPlaying(true);\r\n//         } catch (error) {\r\n//           console.error(\"Error fetching audio:\", error);\r\n//         }\r\n//       };\r\n\r\n//       fetchAudioAndPlay();\r\n//       audioRef.current.volume = volume;\r\n//     }\r\n//   }, [currentTrackIndex]);\r\n\r\n//   return (\r\n//     <AudioContext.Provider\r\n//       value={{\r\n//         currentTrack,\r\n//         setCurrentTrack,\r\n//         isPlaying,\r\n//         setIsPlaying,\r\n//         togglePlay,\r\n//         volume,\r\n//         setVolume,\r\n//         audioFiles,\r\n//         updateAudioFiles,\r\n//         currentTrackIndex,\r\n//         setCurrentTrackIndex,\r\n//         audioRef,\r\n//         debouncedPlayNextTrack,\r\n//         debouncedPlayPreviousTrack,\r\n//         currentTime,\r\n//         setCurrentTime,\r\n//         clearAudioFiles,\r\n//         currentPlaylistId,\r\n//         setCurrentPlaylistId,\r\n//         playlistId,\r\n//         setPlaylistId,\r\n//         localAudioFiles,\r\n//         setLocalAudioFiles,\r\n//         updatePlaylist,\r\n//         audioId,\r\n//         setAudioId,\r\n//         currentPLaylist,\r\n//         setCurrentPlaylis,\r\n//       }}\r\n//     >\r\n//       {children}\r\n//     </AudioContext.Provider>\r\n//   );\r\n// };\r\n\r\n// AudioProvider.propTypes = {\r\n//   children: PropTypes.node.isRequired,\r\n// };\r\n\r\nimport React, {\r\n  createContext,\r\n  useState,\r\n  useContext,\r\n  useEffect,\r\n  useRef,\r\n} from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { debounce } from \"lodash\";\r\n\r\nconst AudioContext = createContext();\r\n\r\nexport const useAudioContext = () => useContext(AudioContext);\r\n\r\nexport const AudioProvider = ({ children }) => {\r\n  const [currentTrack, setCurrentTrack] = useState(null);\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [volume, setVolume] = useState(1);\r\n\r\n  const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const audioRef = useRef(null);\r\n\r\n  const [currentPlaylistId, setCurrentPlaylistId] = useState(-2);\r\n  const [playlistId, setPlaylistId] = useState(-1);\r\n\r\n  const [currentPLaylist, setCurrentPlaylis] = useState(null);\r\n\r\n  const initialPlaylistData = {\r\n    id: null,\r\n    name: '',\r\n    author: '',\r\n    countOfAudio: 0,\r\n    duration: 0.0,\r\n    image: null,\r\n    audioFiles: []\r\n  };\r\n\r\n  const [playlistData, setPlaylistData] = useState(initialPlaylistData);\r\n\r\n  const [localAudioFiles, setLocalAudioFiles] = useState([]);\r\n\r\n  const [audioId, setAudioId] = useState(-1);\r\n\r\n  const clearLocalAudioFiles = () => {\r\n    setLocalAudioFiles([]);\r\n  };\r\n\r\n  useEffect(() => {\r\n    console.log(\r\n      \"useEffect currentPlaylistId:\\n\\ncurrentPlaylistId = \" +\r\n        currentPlaylistId +\r\n        \"\\nplaylistId = \" +\r\n        playlistId\r\n    );\r\n  }, [currentPlaylistId]);\r\n\r\n  const updatePlaylist = (playlistData) => {\r\n    if (currentPlaylistId === playlistId || !isPlaying) {\r\n      console.log(\r\n        \"Обновлен playlistData\\n\\ncurrentPlaylistId = \" +\r\n          currentPlaylistId +\r\n          \"\\nplaylistId = \" +\r\n          playlistId\r\n      );\r\n      setPlaylistData(playlistData);\r\n      console.log(playlistData)\r\n    }\r\n  };\r\n\r\n  const togglePlay = () => {\r\n    setIsPlaying(!isPlaying);\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\r\n      if (\r\n        currentTrackIndex !== -1 &&\r\n        currentPlaylistId === playlistId &&\r\n        playlistData &&\r\n        playlistData.audioFiles &&\r\n        playlistData.audioFiles[currentTrackIndex]\r\n      ) {\r\n        const track = playlistData.audioFiles.find(file => file.id === currentTrackIndex);\r\n\r\n        setCurrentTrack({\r\n          id: track.id,\r\n          audioUrl: track.audioData,\r\n          trackName: track.title,\r\n          author: track.author,\r\n          imageUrl: track.image\r\n            ? `data:image/jpeg;base64,${track.image.data}`\r\n            : \"\",\r\n          duration: playlistData.audioFiles[currentTrackIndex].duration,\r\n        });\r\n      }\r\n    }\r\n  }, [currentTrackIndex]);\r\n\r\n  const playNextTrack = async () => {\r\n    console.log(\"playlistData: \" + playlistData)\r\n    if (!playlistData || !playlistData.audioFiles || currentTrackIndex === -1) return;\r\n    console.log(\"NextTrack:\\n\\ncurrentTrackIndex = \" + currentTrackIndex + \"\\nразмер плейлиста\" + playlistData.audioFiles.length - 1);\r\n\r\n    // if (currentTrackIndex === playlistData.audioFiles.length - 1) return;\r\n  \r\n    let nextIndex = currentTrackIndex + 1;\r\n    // if (nextIndex < playlistData.audioFiles.length) {\r\n      const nextTrack = playlistData.audioFiles.find(file => file.id === nextIndex);\r\n      setCurrentTrackIndex(nextIndex);\r\n      try {\r\n        setCurrentTrack({\r\n          id: nextTrack.id,\r\n          audioUrl: nextTrack.audioData,\r\n          trackName: nextTrack.title,\r\n          author: nextTrack.author,\r\n          imageUrl: nextTrack.image\r\n            ? `data:image/jpeg;base64,${nextTrack.image.data}`\r\n            : \"\",\r\n          duration: nextTrack.duration,\r\n        });\r\n        setIsPlaying(true);\r\n      } catch (error) {\r\n        console.error(\"Error fetching audio:\", error);\r\n      }\r\n    // }\r\n  };\r\n  \r\n  \r\n\r\n  const playPreviousTrack = async () => {\r\n    if (currentTrackIndex === 0) return;\r\n\r\n    console.log(\r\n      \"Предыдущий трек:\\n\\ncurrentPlaylistId = \" +\r\n        currentPlaylistId +\r\n        \"\\nplaylistId = \" +\r\n        playlistId +\r\n        \"\\n\\nтекущий трек = \" +\r\n        audioFiles[currentTrackIndex].title +\r\n        \"\\nпредыдущий трек = \" +\r\n        audioFiles[currentTrackIndex - 1].title\r\n    );\r\n\r\n    let previousIndex = currentTrackIndex - 1;\r\n    while (previousIndex >= 0) {\r\n      const previousTrack = playlistData.audioFiles[previousIndex];\r\n      // if (previousTrack.playlistId === currentPlaylistId) {\r\n      // setCurrentPlaylistId(playlistId);\r\n\r\n      setCurrentTrackIndex(previousIndex);\r\n      try {\r\n        // const response = await fetch(\r\n        //   `http://localhost:8080/api/audio/${previousTrack.id}`\r\n        // );\r\n        // if (!response.ok) {\r\n        //   throw new Error(`HTTP error! status: ${response.status}`);\r\n        // }\r\n        // const blob = await response.blob();\r\n        // const audioData = URL.createObjectURL(blob);\r\n\r\n        setCurrentTrack({\r\n          id: previousTrack.id,\r\n          // audioUrl: audioData,\r\n          audioUrl: previousTrack.audioData,\r\n          trackName: previousTrack.title,\r\n          author: previousTrack.author,\r\n          imageUrl: previousTrack.image\r\n            ? `data:image/jpeg;base64,${previousTrack.image.data}`\r\n            : \"\",\r\n          duration: previousTrack.duration,\r\n        });\r\n        setIsPlaying(true);\r\n        return;\r\n      } catch (error) {\r\n        console.error(\"Error fetching audio:\", error);\r\n      }\r\n\r\n      // }\r\n      previousIndex--;\r\n    }\r\n  };\r\n\r\n  // Задержка перед следующим вызовом\r\n  const debouncedPlayNextTrack = () => {\r\n    console.log(\"currentTrackIndex = \" + currentTrackIndex);\r\n    if (currentTrackIndex !== -1) {\r\n      playNextTrack();\r\n    }\r\n  };\r\n\r\n  // const debouncedPlayNextTrack = debounce(() => {\r\n  //   console.log(ЖcurrentTrackIndex);\r\n  //   if (currentTrackIndex !== -1) {\r\n  //     playNextTrack();\r\n  //   }\r\n  // }, 500);\r\n\r\n  const debouncedPlayPreviousTrack = () => {\r\n    console.log(\"currentTrackIndex = \" + currentTrackIndex);\r\n    if (currentTrackIndex !== -1) {\r\n      playPreviousTrack();\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (currentTrackIndex !== -1 && currentPlaylistId === playlistId) {\r\n      const fetchAudioAndPlay = async () => {\r\n        try {\r\n          if (\r\n            currentTrackIndex !== -1 &&\r\n            currentPlaylistId === playlistId &&\r\n            playlistData &&\r\n            playlistData.audioFiles &&\r\n            playlistData.audioFiles[currentTrackIndex]\r\n          ) {\r\n            const response = await fetch(\r\n              `http://localhost:8080/api/audio/${playlistData.audioFiles[currentTrackIndex].id}`\r\n            );\r\n            if (!response.ok) {\r\n              throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            const blob = await response.blob();\r\n            const audioData = URL.createObjectURL(new Blob([blob]));\r\n\r\n            setCurrentPlaylistId(playlistId);\r\n\r\n            console.log(\r\n              \"playlistData:\",\r\n              playlistData,\r\n              \"currentTrackIndex:\",\r\n              currentTrackIndex,\r\n              \"playlistData.audioFiles:\",\r\n              playlistData.audioFiles,\r\n              \"playlistData.audioFiles[currentTrackIndex]:\",\r\n              playlistData.audioFiles[currentTrackIndex]\r\n            );\r\n\r\n            setCurrentTrack({\r\n              id: playlistData.audioFiles[currentTrackIndex].id,\r\n              audioUrl: audioData,\r\n              trackName: playlistData.audioFiles[currentTrackIndex].title,\r\n              author: playlistData.audioFiles[currentTrackIndex].author,\r\n              imageUrl: playlistData.audioFiles[currentTrackIndex].image\r\n                ? `data:image/jpeg;base64,${playlistData.audioFiles[currentTrackIndex].image.data}`\r\n                : \"\",\r\n              duration: playlistData.audioFiles[currentTrackIndex].duration,\r\n            });\r\n          }\r\n          setIsPlaying(true);\r\n        } catch (error) {\r\n          console.error(\"Error fetching audio:\", error);\r\n        }\r\n      };\r\n\r\n      fetchAudioAndPlay();\r\n      audioRef.current.volume = volume;\r\n    }\r\n  }, [currentTrackIndex]);\r\n\r\n  return (\r\n    <AudioContext.Provider\r\n      value={{\r\n        currentTrack,\r\n        setCurrentTrack,\r\n        isPlaying,\r\n        setIsPlaying,\r\n        togglePlay,\r\n        volume,\r\n        setVolume,\r\n        currentTrackIndex,\r\n        setCurrentTrackIndex,\r\n        audioRef,\r\n        debouncedPlayNextTrack,\r\n        debouncedPlayPreviousTrack,\r\n        currentTime,\r\n        setCurrentTime,\r\n        // clearAudioFiles,\r\n        currentPlaylistId,\r\n        setCurrentPlaylistId,\r\n        playlistId,\r\n        setPlaylistId,\r\n        localAudioFiles,\r\n        setLocalAudioFiles,\r\n        updatePlaylist,\r\n        audioId,\r\n        setAudioId,\r\n        currentPLaylist,\r\n        setCurrentPlaylis,\r\n        clearLocalAudioFiles\r\n      }}\r\n    >\r\n      {children}\r\n    </AudioContext.Provider>\r\n  );\r\n};\r\n\r\nAudioProvider.propTypes = {\r\n  children: PropTypes.node.isRequired,\r\n};\r\n"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}