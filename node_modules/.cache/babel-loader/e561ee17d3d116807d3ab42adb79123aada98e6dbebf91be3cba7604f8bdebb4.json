{"ast":null,"code":"var _jsxFileName = \"D:\\\\\\u0424\\u0430\\u0439\\u043B\\u044B\\\\\\u0412\\u044F\\u0442\\u0413\\u0423\\\\2 \\u043A\\u0443\\u0440\\u0441\\\\\\u0421\\u0435\\u043C\\u0435\\u0441\\u0442\\u0440 4\\\\Web\\\\\\u043A\\u0443\\u0440\\u0441\\u0430\\u0447\\\\audio-service\\\\audio-service-client\\\\src\\\\components\\\\AudioContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect, useRef } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { debounce } from \"lodash\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioContext = /*#__PURE__*/createContext();\nexport const useAudioContext = () => {\n  _s();\n  return useContext(AudioContext);\n};\n_s(useAudioContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const AudioProvider = ({\n  children\n}) => {\n  _s2();\n  const [currentTrack, setCurrentTrack] = useState(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [volume, setVolume] = useState(1);\n  const [audioFiles, setAudioFiles] = useState([]);\n  const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\n  const audioRef = useRef(null);\n  const updateAudioFiles = data => {\n    setAudioFiles(data);\n  };\n  useEffect(() => {\n    if (currentTrackIndex !== -1) {\n      setCurrentTrack({\n        id: audioFiles[currentTrackIndex].id,\n        audioUrl: audioFiles[currentTrackIndex].audioUrl,\n        trackName: audioFiles[currentTrackIndex].title,\n        author: audioFiles[currentTrackIndex].author,\n        imageUrl: audioFiles[currentTrackIndex].image ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}` : \"\"\n      });\n    }\n  }, [audioFiles, currentTrackIndex]);\n  const playNextTrack = () => {\n    if (currentTrackIndex === audioFiles.length - 1) return;\n    const nextIndex = currentTrackIndex + 1;\n    setCurrentTrackIndex(nextIndex);\n    setCurrentTrack({\n      id: audioFiles[nextIndex].id,\n      audioUrl: audioFiles[nextIndex].audioUrl,\n      trackName: audioFiles[nextIndex].title,\n      author: audioFiles[nextIndex].author,\n      imageUrl: audioFiles[nextIndex].image ? `data:image/jpeg;base64,${audioFiles[nextIndex].image.data}` : \"\"\n    });\n  };\n  const playPreviousTrack = () => {\n    if (currentTrackIndex === 0) return;\n    const previousIndex = currentTrackIndex - 1;\n    setCurrentTrackIndex(previousIndex);\n    setCurrentTrack({\n      id: audioFiles[previousIndex].id,\n      audioUrl: audioFiles[previousIndex].audioUrl,\n      trackName: audioFiles[previousIndex].title,\n      author: audioFiles[previousIndex].author,\n      imageUrl: audioFiles[previousIndex].image ? `data:image/jpeg;base64,${audioFiles[previousIndex].image.data}` : \"\"\n    });\n  };\n\n  // Задержка перед следующим вызовом\n  const debouncedPlayNextTrack = debounce(playNextTrack, 500);\n  const debouncedPlayPreviousTrack = debounce(playPreviousTrack, 500);\n  useEffect(() => {\n    if (currentTrackIndex !== -1) {\n      const fetchAudioAndPlay = async () => {\n        try {\n          const response = await fetch(`http://localhost:8080/audio/${audioFiles[currentTrackIndex].id}`);\n          if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n          }\n          const blob = await response.blob();\n          const audioData = URL.createObjectURL(new Blob([blob]));\n          setCurrentTrack({\n            id: audioFiles[currentTrackIndex].id,\n            audioUrl: audioData,\n            trackName: audioFiles[currentTrackIndex].title,\n            author: audioFiles[currentTrackIndex].author,\n            imageUrl: audioFiles[currentTrackIndex].image ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}` : \"\"\n          });\n          setIsPlaying(true);\n        } catch (error) {\n          console.error(\"Error fetching audio:\", error);\n        }\n      };\n      fetchAudioAndPlay();\n    }\n  }, [currentTrackIndex]);\n  return /*#__PURE__*/_jsxDEV(AudioContext.Provider, {\n    value: {\n      currentTrack,\n      setCurrentTrack,\n      isPlaying,\n      setIsPlaying,\n      volume,\n      setVolume,\n      audioFiles,\n      updateAudioFiles,\n      currentTrackIndex,\n      setCurrentTrackIndex,\n      audioRef,\n      debouncedPlayNextTrack,\n      debouncedPlayPreviousTrack\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 108,\n    columnNumber: 5\n  }, this);\n};\n_s2(AudioProvider, \"9Ybk3FqZiMh39MFfNQdwlMNr6VA=\");\n_c = AudioProvider;\nAudioProvider.propTypes = {\n  children: PropTypes.node.isRequired\n};\n\n// import React, {\n//   createContext,\n//   useState,\n//   useContext,\n//   useEffect,\n//   useRef,\n// } from \"react\";\n// import PropTypes from \"prop-types\";\n// import { debounce } from \"lodash\";\n\n// const AudioContext = createContext();\n\n// export const useAudioContext = () => useContext(AudioContext);\n\n// export const AudioProvider = ({ children }) => {\n//   const [currentTrack, setCurrentTrack] = useState(null);\n//   const [isPlaying, setIsPlaying] = useState(false);\n//   const [volume, setVolume] = useState(1);\n//   const [audioFiles, setAudioFiles] = useState([]);\n//   const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\n//   const audioRef = useRef(null);\n\n//   const updateAudioFiles = (data) => {\n//     setAudioFiles(data);\n//   };\n\n//   const togglePlay = () => {\n//     setIsPlaying(!isPlaying);\n//   };\n\n//   useEffect(() => {\n//     if (currentTrackIndex !== -1) {\n//       setCurrentTrack({\n//         id: audioFiles[currentTrackIndex].id,\n//         audioUrl: audioFiles[currentTrackIndex].audioUrl,\n//         trackName: audioFiles[currentTrackIndex].title,\n//         author: audioFiles[currentTrackIndex].author,\n//         imageUrl: audioFiles[currentTrackIndex].image\n//           ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\n//           : \"\",\n//       });\n//     }\n//   }, [audioFiles, currentTrackIndex]);\n\n//   const playNextTrack = () => {\n//     if (currentTrackIndex === audioFiles.length - 1) return;\n//     const nextIndex = currentTrackIndex + 1;\n//     setCurrentTrackIndex(nextIndex);\n//     setCurrentTrack({\n//       id: audioFiles[nextIndex].id,\n//       audioUrl: audioFiles[nextIndex].audioUrl,\n//       trackName: audioFiles[nextIndex].title,\n//       author: audioFiles[nextIndex].author,\n//       imageUrl: audioFiles[nextIndex].image\n//         ? `data:image/jpeg;base64,${audioFiles[nextIndex].image.data}`\n//         : \"\",\n//     });\n//   };\n\n//   const playPreviousTrack = () => {\n//     if (currentTrackIndex === 0) return;\n//     const previousIndex = currentTrackIndex - 1;\n//     setCurrentTrackIndex(previousIndex);\n//     setCurrentTrack({\n//       id: audioFiles[previousIndex].id,\n//       audioUrl: audioFiles[previousIndex].audioUrl,\n//       trackName: audioFiles[previousIndex].title,\n//       author: audioFiles[previousIndex].author,\n//       imageUrl: audioFiles[previousIndex].image\n//         ? `data:image/jpeg;base64,${audioFiles[previousIndex].image.data}`\n//         : \"\",\n//     });\n//   };\n\n//   // Задержка перед следующим вызовом\n//   const debouncedPlayNextTrack = debounce(playNextTrack, 500);\n//   const debouncedPlayPreviousTrack = debounce(playPreviousTrack, 500);\n\n//   useEffect(() => {\n//     if (currentTrackIndex !== -1) {\n//       const fetchAudioAndPlay = async () => {\n//         try {\n//           const response = await fetch(\n//             `http://localhost:8080/audio/${audioFiles[currentTrackIndex].id}`\n//           );\n//           if (!response.ok) {\n//             throw new Error(`HTTP error! status: ${response.status}`);\n//           }\n//           const blob = await response.blob();\n//           const audioData = URL.createObjectURL(new Blob([blob]));\n\n//           setCurrentTrack({\n//             id: audioFiles[currentTrackIndex].id,\n//             audioUrl: audioData,\n//             trackName: audioFiles[currentTrackIndex].title,\n//             author: audioFiles[currentTrackIndex].author,\n//             imageUrl: audioFiles[currentTrackIndex].image\n//               ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\n//               : \"\",\n//           });\n//           setIsPlaying(true);\n//           console.log(\"Вызов из AudioContext:\" + isPlaying)\n//         } catch (error) {\n//           console.error(\"Error fetching audio:\", error);\n//         }\n//       };\n\n//       fetchAudioAndPlay();\n//     }\n//   }, [currentTrackIndex]);\n\n//   return (\n//     <AudioContext.Provider\n//       value={{\n//         currentTrack,\n//         setCurrentTrack,\n//         isPlaying,\n//         setIsPlaying,\n//         togglePlay,\n//         volume,\n//         setVolume,\n//         audioFiles,\n//         updateAudioFiles,\n//         currentTrackIndex,\n//         setCurrentTrackIndex,\n//         audioRef,\n//         debouncedPlayNextTrack,\n//         debouncedPlayPreviousTrack,\n//       }}\n//     >\n//       {children}\n//     </AudioContext.Provider>\n//   );\n// };\n\n// AudioProvider.propTypes = {\n//   children: PropTypes.node.isRequired,\n// };\nvar _c;\n$RefreshReg$(_c, \"AudioProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","useRef","PropTypes","debounce","jsxDEV","_jsxDEV","AudioContext","useAudioContext","_s","AudioProvider","children","_s2","currentTrack","setCurrentTrack","isPlaying","setIsPlaying","volume","setVolume","audioFiles","setAudioFiles","currentTrackIndex","setCurrentTrackIndex","audioRef","updateAudioFiles","data","id","audioUrl","trackName","title","author","imageUrl","image","playNextTrack","length","nextIndex","playPreviousTrack","previousIndex","debouncedPlayNextTrack","debouncedPlayPreviousTrack","fetchAudioAndPlay","response","fetch","ok","Error","status","blob","audioData","URL","createObjectURL","Blob","error","console","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","propTypes","node","isRequired","$RefreshReg$"],"sources":["D:/Файлы/ВятГУ/2 курс/Семестр 4/Web/курсач/audio-service/audio-service-client/src/components/AudioContext.js"],"sourcesContent":["import React, {\r\n  createContext,\r\n  useState,\r\n  useContext,\r\n  useEffect,\r\n  useRef,\r\n} from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { debounce } from \"lodash\"; \r\n\r\nconst AudioContext = createContext();\r\n\r\nexport const useAudioContext = () => useContext(AudioContext);\r\n\r\nexport const AudioProvider = ({ children }) => {\r\n  const [currentTrack, setCurrentTrack] = useState(null);\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [volume, setVolume] = useState(1);\r\n  const [audioFiles, setAudioFiles] = useState([]);\r\n  const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\r\n  const audioRef = useRef(null);\r\n  \r\n  const updateAudioFiles = (data) => {\r\n    setAudioFiles(data);\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (currentTrackIndex !== -1) {\r\n      setCurrentTrack({\r\n        id: audioFiles[currentTrackIndex].id,\r\n        audioUrl: audioFiles[currentTrackIndex].audioUrl,\r\n        trackName: audioFiles[currentTrackIndex].title,\r\n        author: audioFiles[currentTrackIndex].author,\r\n        imageUrl: audioFiles[currentTrackIndex].image\r\n          ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\r\n          : \"\",\r\n      });\r\n    }\r\n  }, [audioFiles, currentTrackIndex]);\r\n\r\n  const playNextTrack = () => {\r\n    if (currentTrackIndex === audioFiles.length - 1) return;\r\n    const nextIndex = currentTrackIndex + 1;\r\n    setCurrentTrackIndex(nextIndex);\r\n    setCurrentTrack({\r\n      id: audioFiles[nextIndex].id,\r\n      audioUrl: audioFiles[nextIndex].audioUrl,\r\n      trackName: audioFiles[nextIndex].title,\r\n      author: audioFiles[nextIndex].author,\r\n      imageUrl: audioFiles[nextIndex].image\r\n        ? `data:image/jpeg;base64,${audioFiles[nextIndex].image.data}`\r\n        : \"\",\r\n    });\r\n  };\r\n\r\n  const playPreviousTrack = () => {\r\n    if (currentTrackIndex === 0) return;\r\n    const previousIndex = currentTrackIndex - 1;\r\n    setCurrentTrackIndex(previousIndex);\r\n    setCurrentTrack({\r\n      id: audioFiles[previousIndex].id,\r\n      audioUrl: audioFiles[previousIndex].audioUrl,\r\n      trackName: audioFiles[previousIndex].title,\r\n      author: audioFiles[previousIndex].author,\r\n      imageUrl: audioFiles[previousIndex].image\r\n        ? `data:image/jpeg;base64,${audioFiles[previousIndex].image.data}`\r\n        : \"\",\r\n    });\r\n  };\r\n\r\n  // Задержка перед следующим вызовом\r\n  const debouncedPlayNextTrack = debounce(playNextTrack, 500); \r\n  const debouncedPlayPreviousTrack = debounce(playPreviousTrack, 500);\r\n\r\n  useEffect(() => {\r\n    if (currentTrackIndex !== -1) {\r\n      const fetchAudioAndPlay = async () => {\r\n        try {\r\n          const response = await fetch(\r\n            `http://localhost:8080/audio/${audioFiles[currentTrackIndex].id}`\r\n          );\r\n          if (!response.ok) {\r\n            throw new Error(`HTTP error! status: ${response.status}`);\r\n          }\r\n          const blob = await response.blob();\r\n          const audioData = URL.createObjectURL(new Blob([blob]));\r\n\r\n          setCurrentTrack({\r\n            id: audioFiles[currentTrackIndex].id,\r\n            audioUrl: audioData,\r\n            trackName: audioFiles[currentTrackIndex].title,\r\n            author: audioFiles[currentTrackIndex].author,\r\n            imageUrl: audioFiles[currentTrackIndex].image\r\n              ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\r\n              : \"\",\r\n          });\r\n          setIsPlaying(true);\r\n        } catch (error) {\r\n          console.error(\"Error fetching audio:\", error);\r\n        }\r\n      };\r\n\r\n      fetchAudioAndPlay();\r\n    }\r\n  }, [currentTrackIndex]);\r\n\r\n  return (\r\n    <AudioContext.Provider\r\n      value={{\r\n        currentTrack,\r\n        setCurrentTrack,\r\n        isPlaying,\r\n        setIsPlaying,\r\n        volume,\r\n        setVolume,\r\n        audioFiles,\r\n        updateAudioFiles,\r\n        currentTrackIndex,\r\n        setCurrentTrackIndex,\r\n        audioRef,\r\n        debouncedPlayNextTrack,\r\n        debouncedPlayPreviousTrack,\r\n      }}\r\n    >\r\n      {children}\r\n    </AudioContext.Provider>\r\n  );\r\n};\r\n\r\nAudioProvider.propTypes = {\r\n  children: PropTypes.node.isRequired,\r\n};\r\n\r\n// import React, {\r\n//   createContext,\r\n//   useState,\r\n//   useContext,\r\n//   useEffect,\r\n//   useRef,\r\n// } from \"react\";\r\n// import PropTypes from \"prop-types\";\r\n// import { debounce } from \"lodash\";\r\n\r\n// const AudioContext = createContext();\r\n\r\n// export const useAudioContext = () => useContext(AudioContext);\r\n\r\n// export const AudioProvider = ({ children }) => {\r\n//   const [currentTrack, setCurrentTrack] = useState(null);\r\n//   const [isPlaying, setIsPlaying] = useState(false);\r\n//   const [volume, setVolume] = useState(1);\r\n//   const [audioFiles, setAudioFiles] = useState([]);\r\n//   const [currentTrackIndex, setCurrentTrackIndex] = useState(-1);\r\n//   const audioRef = useRef(null);\r\n\r\n//   const updateAudioFiles = (data) => {\r\n//     setAudioFiles(data);\r\n//   };\r\n\r\n//   const togglePlay = () => {\r\n//     setIsPlaying(!isPlaying);\r\n//   };\r\n\r\n//   useEffect(() => {\r\n//     if (currentTrackIndex !== -1) {\r\n//       setCurrentTrack({\r\n//         id: audioFiles[currentTrackIndex].id,\r\n//         audioUrl: audioFiles[currentTrackIndex].audioUrl,\r\n//         trackName: audioFiles[currentTrackIndex].title,\r\n//         author: audioFiles[currentTrackIndex].author,\r\n//         imageUrl: audioFiles[currentTrackIndex].image\r\n//           ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\r\n//           : \"\",\r\n//       });\r\n//     }\r\n//   }, [audioFiles, currentTrackIndex]);\r\n\r\n//   const playNextTrack = () => {\r\n//     if (currentTrackIndex === audioFiles.length - 1) return;\r\n//     const nextIndex = currentTrackIndex + 1;\r\n//     setCurrentTrackIndex(nextIndex);\r\n//     setCurrentTrack({\r\n//       id: audioFiles[nextIndex].id,\r\n//       audioUrl: audioFiles[nextIndex].audioUrl,\r\n//       trackName: audioFiles[nextIndex].title,\r\n//       author: audioFiles[nextIndex].author,\r\n//       imageUrl: audioFiles[nextIndex].image\r\n//         ? `data:image/jpeg;base64,${audioFiles[nextIndex].image.data}`\r\n//         : \"\",\r\n//     });\r\n//   };\r\n\r\n//   const playPreviousTrack = () => {\r\n//     if (currentTrackIndex === 0) return;\r\n//     const previousIndex = currentTrackIndex - 1;\r\n//     setCurrentTrackIndex(previousIndex);\r\n//     setCurrentTrack({\r\n//       id: audioFiles[previousIndex].id,\r\n//       audioUrl: audioFiles[previousIndex].audioUrl,\r\n//       trackName: audioFiles[previousIndex].title,\r\n//       author: audioFiles[previousIndex].author,\r\n//       imageUrl: audioFiles[previousIndex].image\r\n//         ? `data:image/jpeg;base64,${audioFiles[previousIndex].image.data}`\r\n//         : \"\",\r\n//     });\r\n//   };\r\n\r\n//   // Задержка перед следующим вызовом\r\n//   const debouncedPlayNextTrack = debounce(playNextTrack, 500);\r\n//   const debouncedPlayPreviousTrack = debounce(playPreviousTrack, 500);\r\n\r\n//   useEffect(() => {\r\n//     if (currentTrackIndex !== -1) {\r\n//       const fetchAudioAndPlay = async () => {\r\n//         try {\r\n//           const response = await fetch(\r\n//             `http://localhost:8080/audio/${audioFiles[currentTrackIndex].id}`\r\n//           );\r\n//           if (!response.ok) {\r\n//             throw new Error(`HTTP error! status: ${response.status}`);\r\n//           }\r\n//           const blob = await response.blob();\r\n//           const audioData = URL.createObjectURL(new Blob([blob]));\r\n\r\n//           setCurrentTrack({\r\n//             id: audioFiles[currentTrackIndex].id,\r\n//             audioUrl: audioData,\r\n//             trackName: audioFiles[currentTrackIndex].title,\r\n//             author: audioFiles[currentTrackIndex].author,\r\n//             imageUrl: audioFiles[currentTrackIndex].image\r\n//               ? `data:image/jpeg;base64,${audioFiles[currentTrackIndex].image.data}`\r\n//               : \"\",\r\n//           });\r\n//           setIsPlaying(true);\r\n//           console.log(\"Вызов из AudioContext:\" + isPlaying)\r\n//         } catch (error) {\r\n//           console.error(\"Error fetching audio:\", error);\r\n//         }\r\n//       };\r\n\r\n//       fetchAudioAndPlay();\r\n//     }\r\n//   }, [currentTrackIndex]);\r\n\r\n//   return (\r\n//     <AudioContext.Provider\r\n//       value={{\r\n//         currentTrack,\r\n//         setCurrentTrack,\r\n//         isPlaying,\r\n//         setIsPlaying,\r\n//         togglePlay,\r\n//         volume,\r\n//         setVolume,\r\n//         audioFiles,\r\n//         updateAudioFiles,\r\n//         currentTrackIndex,\r\n//         setCurrentTrackIndex,\r\n//         audioRef,\r\n//         debouncedPlayNextTrack,\r\n//         debouncedPlayPreviousTrack,\r\n//       }}\r\n//     >\r\n//       {children}\r\n//     </AudioContext.Provider>\r\n//   );\r\n// };\r\n\r\n// AudioProvider.propTypes = {\r\n//   children: PropTypes.node.isRequired,\r\n// };\r\n"],"mappings":";;;AAAA,OAAOA,KAAK,IACVC,aAAa,EACbC,QAAQ,EACRC,UAAU,EACVC,SAAS,EACTC,MAAM,QACD,OAAO;AACd,OAAOC,SAAS,MAAM,YAAY;AAClC,SAASC,QAAQ,QAAQ,QAAQ;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAElC,MAAMC,YAAY,gBAAGT,aAAa,CAAC,CAAC;AAEpC,OAAO,MAAMU,eAAe,GAAGA,CAAA;EAAAC,EAAA;EAAA,OAAMT,UAAU,CAACO,YAAY,CAAC;AAAA;AAACE,EAAA,CAAjDD,eAAe;AAE5B,OAAO,MAAME,aAAa,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,GAAA;EAC7C,MAAM,CAACC,YAAY,EAAEC,eAAe,CAAC,GAAGf,QAAQ,CAAC,IAAI,CAAC;EACtD,MAAM,CAACgB,SAAS,EAAEC,YAAY,CAAC,GAAGjB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACkB,MAAM,EAAEC,SAAS,CAAC,GAAGnB,QAAQ,CAAC,CAAC,CAAC;EACvC,MAAM,CAACoB,UAAU,EAAEC,aAAa,CAAC,GAAGrB,QAAQ,CAAC,EAAE,CAAC;EAChD,MAAM,CAACsB,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGvB,QAAQ,CAAC,CAAC,CAAC,CAAC;EAC9D,MAAMwB,QAAQ,GAAGrB,MAAM,CAAC,IAAI,CAAC;EAE7B,MAAMsB,gBAAgB,GAAIC,IAAI,IAAK;IACjCL,aAAa,CAACK,IAAI,CAAC;EACrB,CAAC;EAEDxB,SAAS,CAAC,MAAM;IACd,IAAIoB,iBAAiB,KAAK,CAAC,CAAC,EAAE;MAC5BP,eAAe,CAAC;QACdY,EAAE,EAAEP,UAAU,CAACE,iBAAiB,CAAC,CAACK,EAAE;QACpCC,QAAQ,EAAER,UAAU,CAACE,iBAAiB,CAAC,CAACM,QAAQ;QAChDC,SAAS,EAAET,UAAU,CAACE,iBAAiB,CAAC,CAACQ,KAAK;QAC9CC,MAAM,EAAEX,UAAU,CAACE,iBAAiB,CAAC,CAACS,MAAM;QAC5CC,QAAQ,EAAEZ,UAAU,CAACE,iBAAiB,CAAC,CAACW,KAAK,GACxC,0BAAyBb,UAAU,CAACE,iBAAiB,CAAC,CAACW,KAAK,CAACP,IAAK,EAAC,GACpE;MACN,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAACN,UAAU,EAAEE,iBAAiB,CAAC,CAAC;EAEnC,MAAMY,aAAa,GAAGA,CAAA,KAAM;IAC1B,IAAIZ,iBAAiB,KAAKF,UAAU,CAACe,MAAM,GAAG,CAAC,EAAE;IACjD,MAAMC,SAAS,GAAGd,iBAAiB,GAAG,CAAC;IACvCC,oBAAoB,CAACa,SAAS,CAAC;IAC/BrB,eAAe,CAAC;MACdY,EAAE,EAAEP,UAAU,CAACgB,SAAS,CAAC,CAACT,EAAE;MAC5BC,QAAQ,EAAER,UAAU,CAACgB,SAAS,CAAC,CAACR,QAAQ;MACxCC,SAAS,EAAET,UAAU,CAACgB,SAAS,CAAC,CAACN,KAAK;MACtCC,MAAM,EAAEX,UAAU,CAACgB,SAAS,CAAC,CAACL,MAAM;MACpCC,QAAQ,EAAEZ,UAAU,CAACgB,SAAS,CAAC,CAACH,KAAK,GAChC,0BAAyBb,UAAU,CAACgB,SAAS,CAAC,CAACH,KAAK,CAACP,IAAK,EAAC,GAC5D;IACN,CAAC,CAAC;EACJ,CAAC;EAED,MAAMW,iBAAiB,GAAGA,CAAA,KAAM;IAC9B,IAAIf,iBAAiB,KAAK,CAAC,EAAE;IAC7B,MAAMgB,aAAa,GAAGhB,iBAAiB,GAAG,CAAC;IAC3CC,oBAAoB,CAACe,aAAa,CAAC;IACnCvB,eAAe,CAAC;MACdY,EAAE,EAAEP,UAAU,CAACkB,aAAa,CAAC,CAACX,EAAE;MAChCC,QAAQ,EAAER,UAAU,CAACkB,aAAa,CAAC,CAACV,QAAQ;MAC5CC,SAAS,EAAET,UAAU,CAACkB,aAAa,CAAC,CAACR,KAAK;MAC1CC,MAAM,EAAEX,UAAU,CAACkB,aAAa,CAAC,CAACP,MAAM;MACxCC,QAAQ,EAAEZ,UAAU,CAACkB,aAAa,CAAC,CAACL,KAAK,GACpC,0BAAyBb,UAAU,CAACkB,aAAa,CAAC,CAACL,KAAK,CAACP,IAAK,EAAC,GAChE;IACN,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,MAAMa,sBAAsB,GAAGlC,QAAQ,CAAC6B,aAAa,EAAE,GAAG,CAAC;EAC3D,MAAMM,0BAA0B,GAAGnC,QAAQ,CAACgC,iBAAiB,EAAE,GAAG,CAAC;EAEnEnC,SAAS,CAAC,MAAM;IACd,IAAIoB,iBAAiB,KAAK,CAAC,CAAC,EAAE;MAC5B,MAAMmB,iBAAiB,GAAG,MAAAA,CAAA,KAAY;QACpC,IAAI;UACF,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CACzB,+BAA8BvB,UAAU,CAACE,iBAAiB,CAAC,CAACK,EAAG,EAClE,CAAC;UACD,IAAI,CAACe,QAAQ,CAACE,EAAE,EAAE;YAChB,MAAM,IAAIC,KAAK,CAAE,uBAAsBH,QAAQ,CAACI,MAAO,EAAC,CAAC;UAC3D;UACA,MAAMC,IAAI,GAAG,MAAML,QAAQ,CAACK,IAAI,CAAC,CAAC;UAClC,MAAMC,SAAS,GAAGC,GAAG,CAACC,eAAe,CAAC,IAAIC,IAAI,CAAC,CAACJ,IAAI,CAAC,CAAC,CAAC;UAEvDhC,eAAe,CAAC;YACdY,EAAE,EAAEP,UAAU,CAACE,iBAAiB,CAAC,CAACK,EAAE;YACpCC,QAAQ,EAAEoB,SAAS;YACnBnB,SAAS,EAAET,UAAU,CAACE,iBAAiB,CAAC,CAACQ,KAAK;YAC9CC,MAAM,EAAEX,UAAU,CAACE,iBAAiB,CAAC,CAACS,MAAM;YAC5CC,QAAQ,EAAEZ,UAAU,CAACE,iBAAiB,CAAC,CAACW,KAAK,GACxC,0BAAyBb,UAAU,CAACE,iBAAiB,CAAC,CAACW,KAAK,CAACP,IAAK,EAAC,GACpE;UACN,CAAC,CAAC;UACFT,YAAY,CAAC,IAAI,CAAC;QACpB,CAAC,CAAC,OAAOmC,KAAK,EAAE;UACdC,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEA,KAAK,CAAC;QAC/C;MACF,CAAC;MAEDX,iBAAiB,CAAC,CAAC;IACrB;EACF,CAAC,EAAE,CAACnB,iBAAiB,CAAC,CAAC;EAEvB,oBACEf,OAAA,CAACC,YAAY,CAAC8C,QAAQ;IACpBC,KAAK,EAAE;MACLzC,YAAY;MACZC,eAAe;MACfC,SAAS;MACTC,YAAY;MACZC,MAAM;MACNC,SAAS;MACTC,UAAU;MACVK,gBAAgB;MAChBH,iBAAiB;MACjBC,oBAAoB;MACpBC,QAAQ;MACRe,sBAAsB;MACtBC;IACF,CAAE;IAAA5B,QAAA,EAEDA;EAAQ;IAAA4C,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACY,CAAC;AAE5B,CAAC;AAAC9C,GAAA,CAjHWF,aAAa;AAAAiD,EAAA,GAAbjD,aAAa;AAmH1BA,aAAa,CAACkD,SAAS,GAAG;EACxBjD,QAAQ,EAAER,SAAS,CAAC0D,IAAI,CAACC;AAC3B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA,IAAAH,EAAA;AAAAI,YAAA,CAAAJ,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}